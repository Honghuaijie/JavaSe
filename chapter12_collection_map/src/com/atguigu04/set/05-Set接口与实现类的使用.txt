
1. Set及其实现类特点
java.util.Collection:存储一个一个的数据(“动态”数组）
    |-----子接口：Set:存储无序的、不可重复的数据
        |--- 实现类：HashSet（主要实现类）： 底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（JDK8中）
            |--  LinkedHashSet: 是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，有添加了
                                一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺序实现遍历。
                                便于我们频繁的查询操作
        |--  treeSet：底层使用红黑树存储。可以按照添加的元素的指定属性的大小顺序进行遍历


2. 开发中的使用频率及场景:
> 较List、Map来说，Set使用频率比较少。
> 用来过滤重复数据


3. Set中常用方法:即为collection中声明的15个抽象方法。没有新增的方法



4. Set中无序性、不可重复性的理解（以HashSet及其子类为例说明）

>无序性：！=随机性。
        添加元素的顺序和遍历元素的顺序不一致，是不是就是无序性？No！
        到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的
        这里是根据添加的元素的哈希值，计算的其在数组中的存储位置，此位置不是依次排序的，表现为无序性
>不可重复性：添加到set中的元素是不能相同的。比较的标准需要判断hashCode然后再判断equals。
    哈希值相同且equals()返回true，则认为元素相同


5. 添加到HashSet/LinkedHashSet中元素的要求:
元素所在的类要重写两个方法，equals和hashCode，要求两个方法要保持一致性！我们只需要自动生成两个方法的重写就可以了


6. TreeSet的使用
6.1 底层的数据结构：红黑树

6.2 添加数据后的特点：可以按照添加的元素的指定属性的大小顺序进行遍历


6.3 向TreeSet中添加的元素的要求：
> 要求添加到treeset中的元素必须是同一个类型的对象，否则会报classCastException
> 添加的元素需要考虑排序：①自然排序  ②  定制排序


6.4 判断数据是否相同的标准
> 不在是考虑hashcode和equals方法了。也就意味着添加到treeset中的元素，不需要去重写着两个方法了
> 比较元素大小或比较元素是否相等的标准就是需要考虑自然排序和定制排序中，compareTo或compare的返回值。
    如果返回值为0则认为两个对象相等，由于treeset中不能存放相同的元素，则后一个相等的元素就不能添加到treeset

